<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0053-enum-entities - Cedar RFC Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cedar RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="enumerated-entity-types"><a class="header" href="#enumerated-entity-types">Enumerated Entity Types</a></h1>
<h2 id="timeline"><a class="header" href="#timeline">Timeline</a></h2>
<ul>
<li>Started: 2024-02-20</li>
<li>Accepted: 2024-03-20</li>
<li>Landed: TBD</li>
<li>Released: TBD</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Extend schemas to support declared enumerations of entity-typed values, analogous to how schemas can currently be used to enumerate a finite list of <code>Action</code>-typed values.</p>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic example</a></h2>
<p>An enumerated entity type is declared as a normal entity type, but includes the keyword <code>enum</code> followed by the list of legal entity UIDs. Here is a simple example:</p>
<pre><code>entity User;
entity Color enum ["Red", "Blue", "Green"];
entity Task {
    owner: User,
    name: String,
    status: Color
};
action UpdateTask
    appliesTo { principal: [User], resource: [Task] };
</code></pre>
<p>These data definitions could be used in policies such as</p>
<pre><code>permit(
    principal,
    action == Action::"UpdateTask",
    resource)
when {
    principal == resource.owner &amp;&amp;
    resource.status != Color::"Red"
};
</code></pre>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Enumerated types are useful when you have a fixed set of possible values, and the only thing you want to do with the values is compare them for equality. While you could effectively treat an entity type as an enumeration now, without declaring it in a schema, you gain some benefits by declaring it:</p>
<ul>
<li>The validator can error on uses of illegal enumerated values, e.g., flagging the typo <code>resource.status != Color::"red"</code> in the <code>when</code> clause in the basic example.</li>
<li>When using a policy analyzer, it can always generate request and entity store instances where the enumerated entity type has declared-valid values, rather than random UIDs.</li>
<li>When using an IDE or web-based policy builder, the enumeration can inform auto-completion suggestions. For the basic example above, in an auto-completing IDE writing <code>resource.status != </code> ... would pop up the three options.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>An enumerated entity <code>Foo</code> is declared by writing</p>
<pre><code>entity Foo enum [ â€¦ ];
</code></pre>
<p>where <code>[</code> â€¦ <code>]</code> is a non-empty list of allowed values, expressed as strings.</p>
<p>In the JSON format for schemas, you would write</p>
<pre><code>"entityTypes": {
    ...
    "Foo": {
        "enum": [ â€¦ ]
    },
    ...
}
</code></pre>
<p>You can use an enumerated entity type anywhere you can use a normal entity type. Since an enumerated entity cannot have attributes, nor can it have ancestors in the entity hierarchy, all you can do with it is test it for equality (e.g., with <code>==</code> or <code>contains</code>).</p>
<p>The policy validator confirms that any enumerated entity literal in a policy is valid. The request validator does likewise. The entity store validator confirms that enumerated entities <em>do not</em> appear in the store, or if they do, they have no attributes or ancestors. It also confirms that the declared enumerated entity type has no invalid values, and references to entities of the enumerated type are valid. The schema-based entity parser likewise confirms that parsed-in enumerated entity values are valid.</p>
<p>As another example, consider the following.</p>
<pre><code>entity Application enum [ "TinyTodo" ];
entity User in [ Application ];
action CreateList
    appliesTo { principal: [User], resource: [Application] };
</code></pre>
<p>This is a generalization of our TinyTodo example from RFC 24, where we can refine the definition of <code>Application</code> to indicate that it has a single value, <code>Application::"TinyTodo"</code>. This allows the validator to catch typos in policies, such as the following.</p>
<pre><code>permit(
    principal,
    action in [Action::"CreateList"],
    resource == Application::"TinyTODO"
);
</code></pre>
<p>Likewise the request validator would flag a request with <code>Application::"TinyTODO"</code> as its resource, and it would flag the passed-in entity store if it contained such an illegal value.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>As a convention, our example enumerated entity names, like <code>Color::"Red"</code> or <code>Application::"TinyTodo"</code>, all begin with an uppercase letter. We choose to consider this approach good style, but not to mandate it.</p>
<p>We require entity enumerations to be given as a non-empty list of strings, like <code>["Red", "Blue"]</code>, but we could also allow them to be specified as identifiers, like <code>[ Red, Blue ]</code>. Doing so would be similar to the handling of attributes, which can be specified as identifiers, <code>principal.owner</code>, or as strings, <code>principal["owner"]</code>. However, entity enumerations can only be <em>referenced</em> as strings, e.g., as <code>Color::"Red"</code> not <code>Color::Red</code>. Specifying them as strings, only, makes this connection a little stronger.</p>
<p>We do not permit declaring empty enumerations. Allowing them would add complication to policy analysis (to consider the exceptional case), but would be essentially useless: You could never create an entity of type <code>Foo</code>, where <code>Foo</code> is uninhabited, and while you could write <code>expr is Foo</code>, this expression is always <code>false</code>.</p>
<p>That an entity is an enumeration is specified as a refinement when declaring the entity type, e.g., writing <code>entity Application;</code> declares the <code>Application</code> entity type, while writing <code>entity Application enum ["TinyTodo"];</code> declares the <code>Application</code> entity type and then refines it to say that only the <code>"TinyTodo"</code> entity ID is well defined. An alternative syntax that is more intuitive to some readers is <code>entity enum Application ["TinyTodo"]</code>. This syntax is similar to Java-style syntax, <code>enum Application { TinyTodo }</code>. However, this approach could create some confusion: <code>enum</code> is currently a valid entity type, so it's legal to write <code>entity enum;</code> in schemas today. Moreover, if we eventually take Alternative C, below, we may allow <code>enum</code> to be accompanied by other type refinements, such as <code>in</code> and attribute declarations. For example, we could one day be able to write <code>entity Application in [Application] enum ["TinyTodo", "Office"]</code> (or swapping their order, <code>entity Application enum ["TinyTodo", "Office"] in [Application]</code>), and might prefer the uniformity of that to <code>entity enum Application ["TinyTodo", "Office"] in [Application]</code>.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>One reason not to do this is that it's not particularly full featured---you cannot do anything useful with an enumerated entity value in a policy other than compare it for equality. We consider more full-featured extensions in the alternatives below, but these have drawbacks of their own. The functionality could be easily extended later, depending on how things play out.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="alternative-a-enumerated-primitive-values"><a class="header" href="#alternative-a-enumerated-primitive-values">Alternative A: Enumerated primitive values</a></h3>
<p>We previously proposed, in <a href="https://github.com/cedar-policy/rfcs/blob/enums/text/0013-schema-enums.md">RFC 13</a>, declaring a finite set of primitive values (strings, numbers, etc.) as an enumerated type. The <a href="https://github.com/cedar-policy/rfcs/pull/13#issuecomment-1786170514">killer objection to the RFC</a> is that it introduces subtyping (you want to use the enumerated type of string as both the enumeration and the string, e.g., with <code>like</code>), which is a significant complication for policy analysis. The present proposal is not problematic for analysis as enumerated entities can be encoded like any entity, but with added ground constraints limiting what form their UIDs can take on.</p>
<h3 id="alternative-b-enumeration-as-a-distinct-concept"><a class="header" href="#alternative-b-enumeration-as-a-distinct-concept">Alternative B: Enumeration as a distinct concept</a></h3>
<p>Rather than specify a particular entity type as an enumeration, we could define a new concept of enumeration as another kind of primitive type. Here is a notional schema:</p>
<pre><code>enum type Color = Red | Blue | Green;
entity Task {
  name: String,
  status: Color
};
</code></pre>
<p>Here is a notional policy:</p>
<pre><code>permit(
    principal,
    action == Action::"UpdateTask",
    resource)
when {
    resource.status != Color.Red
};
</code></pre>
<p>This syntax is similar to what's provided for Java <code>enum</code>s.</p>
<p>The benefit of this approach is that it may feel a little more natural than representing a concept, like a color, as a set of legal entity values. It would also be easy to encode this approach in a policy analysis.</p>
<p>The main drawback of this approach is that it introduces a new primitive type to the language that does not make much sense without schemas. Recall that for Cedar, validation with a schema is <em>optional</em>. We'd allow users to include any random enumerated identifiers (like Scheme-style <em>symbols</em>) in policies which, without validation, would fail equality checks at run-time.</p>
<p>The proposed approach that lists particular entity values as an enumeration makes no change to the language, leveraging the existing entity type concept. So policies without schemas still make sense. With the added schema, there is additional benefit when validating and constructing reasonable policies.</p>
<h3 id="alternative-c-enumerated-entities-with-hierarchy"><a class="header" href="#alternative-c-enumerated-entities-with-hierarchy">Alternative C: Enumerated entities with hierarchy</a></h3>
<p>Enumerated entities as proposed are limited in their functionality and specificity. We could extend them. For example:</p>
<pre><code>entity Application enum [ "TinyTodo" ];
entity RequestEntity enum [ "Principal", "Resource" ] in [ Application ];
entity User in [ Application ];
action CreateList
    appliesTo { principal: [User], resource: [Application] };
action GetLists
    appliesTo { principal: [User, RequestEntity::"Principal"],
                resource: [Application]};
</code></pre>
<p>This differs from some earlier examples in the following ways:</p>
<ol>
<li>Enumerated entities can have parents that are enumerated entity values, and can be parents of other enumerated entity values; both cases are shown in the definition of <code>RequestEntity</code></li>
<li>Enumerated entities can appear as <em>singleton types</em>, e.g., as <code>RequestEntity::"Principal"</code> in the definition of action <code>GetLists</code>.</li>
</ol>
<p>Both of these extensions are similar to what's available for <code>Action</code>s right now, but generalized to arbitrary entity types. You could also imagine enumerated entity types having attributes, as has been anticipated for <code>Action</code>s.</p>
<p>One drawback of this Alternative is that it creates added complication for both the validator (e.g., to handle singleton types) and the analyzer (e.g., to deal with the more general hierarchy constraints).</p>
<p>Another drawback is that it adds complication to the entity store: Once you add hierarchy constraints and attributes, you need to create actual entities to include with policy requests, by extracting them from the schema at request-time. The RFC as proposed does not require that.</p>
<p>The good news is that this Alternative is a strict generalization of the RFC as proposed, which means if we agree to the current proposal we can later upgrade to some or all of this Alternative without incurring a breaking change.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0052-reserved-namespaces.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="0055-remove-unspecified.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0052-reserved-namespaces.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="0055-remove-unspecified.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
