<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0019-stricter-validation - Cedar RFC Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cedar RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="standalone-strict-validation"><a class="header" href="#standalone-strict-validation">Standalone strict validation</a></h1>
<h2 id="related-issues-and-prs"><a class="header" href="#related-issues-and-prs">Related issues and PRs</a></h2>
<ul>
<li>Reference Issues:</li>
<li>Implementation PR(s): https://github.com/cedar-policy/cedar/pull/282 and https://github.com/cedar-policy/cedar-spec/pull/111</li>
</ul>
<h2 id="timeline"><a class="header" href="#timeline">Timeline</a></h2>
<ul>
<li>Started: 2023-07-11</li>
<li>Accepted: 2023-09-05</li>
<li>Landed: 2023-09-08 on <code>main</code></li>
<li>Released: 2023-12-15 in <code>cedar-policy</code> v3.0.0</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Internally, strict validation of a policy is implemented as 1/ checking and transforming the policy using a <em>permissive</em> validation mode; 2/ annotating the transformed policy with types, and 3/ checking the types against more restrictive rules. We would like to be able to at least <em>explain</em> strict mode independently of permissive mode, but there is no easy way to do that. This RFC proposes to separate strict mode from permissive mode, making the implementation simpler and more understandable/explainable, though somewhat more strict.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Consider this policy, given in file <a href="./0019/policy.cedar"><code>policy.cedar</code></a>, where <code>principal</code> is always of type <code>User</code>:</p>
<pre><code>permit(
    principal,
    action == Action::"read",
    resource)
when {
  (if context.sudo then Admin::"root" else principal) == resource.owner ||
  resource.isPublic
}
</code></pre>
<p>If we validate this policy against the schema <a href="./0019/schema.cedarschema.json"><code>schema.cedarschema.json</code></a>, then <code>resource.owner</code> is always of type <code>User</code>. As a result, the policy is rejected by strict-mode validation, with two errors:</p>
<ol>
<li>the <code>if</code>/<code>then</code>/<code>else</code> is trying to return entity type <code>Admin</code> in the true branch, and entity type <code>User</code> on the false branch, and these two are not equal.</li>
<li>since <code>resource.owner</code> has type <code>User</code>, it will have a type different than that returned by the <code>if</code>/<code>then</code>/<code>else</code>, which can sometimes return <code>Admin</code>.</li>
</ol>
<p>But if we change <code>"User"</code> in <a href="./0019/schema.cedarschema.json"><code>schema.cedarschema.json</code></a> on line 13 to <code>"Org"</code>, then <code>resource.owner</code> is always of type <code>Org</code>. As a result, the policy is accepted! The two error conditions given above seem not to have changed -- the conditional returns different types, and those types may not equal the type of <code>resource.owner</code> -- so it's puzzling what changed to make the policy acceptable.</p>
<p>The reason is that strict-mode validation is dependent on permissive-mode validation. In particular, strict-mode validation is implemented in three steps: 1/ validate and transform the policy using permissive mode; 2/ annotate the transformed policy AST with types; and 3/ check the types against more restrictive rules.</p>
<p>In the first case, when <code>resource.owner</code> is always of type <code>User</code>, the expression <code>(if ...) == resource.owner</code> has type <code>Boolean</code> in permissive mode and as a result no transformation takes place in step 1. As a result, it is rejected in step 3 due to the errors given above.</p>
<p>In the second case (after we change the schema), <code>resource.owner</code> is always of type <code>Org</code>. Under permissive mode, the <code>(if ...) == resource.owner</code> expression has singleton type <code>False</code>. That’s because the <code>(if ...)</code> expression has type <code>User|Admin</code> ("<code>User</code> or <code>Admin</code>") and <code>User|Admin</code> entities can never be equal to <code>Org</code> entities. Both the <em>singleton type</em> <code>False</code> (which only validates an expression that <em>always</em> evaluates to <code>false</code>) and <em>union types</em> like <code>User|Admin</code> are features of permissive mode and are not present in strict mode. Because of these features, step 1 will replace the <code>False</code>-typed <code>(if ...) == resource.owner</code> with value <code>false</code>, transforming the policy to be <code>permit(principal,action,resource) when { false || resource.isPublic }</code>. Since this policy does not require union types and otherwise meets strict mode restrictions, it is accepted in step 3.</p>
<p>In sum: To see why the second case is acceptable, we have to understand the interaction between permissive mode and strict mode. This is subtle and difficult to explain. Instead, we want to implement strict mode as a standalone feature, which does not depend on features only present in permissive mode.</p>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>We propose to change strict-mode validation so that it has the following features taken from permissive mode:</p>
<ul>
<li>Singleton boolean <code>True</code>/<code>False</code> types (which have 1/ special consideration of them with <code>&amp;&amp;</code>, <code>||</code>, and conditionals, and 2/ subtyping between them and <code>Boolean</code>, as is done now for permissive mode).</li>
<li>Depth subtyping, but not width subtyping, to support examples like <code>{ foo: True } &lt;: { foo: Boolean }</code>.</li>
</ul>
<p>Strict-mode validation will continue to apply the restriction it currently applies:</p>
<ul>
<li>Arguments to <code>==</code> must have the compatibles types (i.e., an upper bound exists according to the strict - depth only - definitions of subtyping) <em>unless</em> we know that comparison will always be false, in which case we can give the <code>==</code> type <code>False</code>. The same goes for <code>contains</code>, <code>containsAll</code>, and <code>containsAny</code>.</li>
<li>Arguments to an <code>in</code> expression must be compatible with the entity type hierarchy, or we must know that the comparison is always false.</li>
<li>Branches of a conditional must have compatible types <em>unless</em> we can simplify the conditional due to the guard having a <code>True</code>/<code>False</code> type.</li>
<li>The elements of a set must have compatible types.</li>
<li>As a consequence of the two prior restrictions, union types cannot be constructed.</li>
<li>Empty set literals may not exist in a policy because we do not currently infer the type of the elements of an empty set.</li>
<li>Extension type constructors may only be applied to literals.</li>
</ul>
<p>Validating <code>Action</code> entities and template slots <code>?principal</code> and <code>?resource</code> must be done differently so as not to rely on the "top" entity type <em>AnyEntity</em>, which is essentially an infinite-width union type, used internally.
Next, we describe how we propose to handle these situations, in both permissive and strict validation.
Importantly, these changes all retain or even <em>improve</em> precision compared to the status quo -- they will <em>not</em> be the reason that policies that typechecked under the old strict mode no longer do.</p>
<h3 id="actions"><a class="header" href="#actions">Actions</a></h3>
<p>Permissive mode validation considers different <code>Action</code>s to have distinct types, e.g., <code>Action::"view"</code> and <code>Action::"update"</code> don't have the same type.
This is in anticipation of supporting distinct actions having distinct attribute sets.
The least upper bound of any two actions is the type <em>AnyEntity</em>.
Such a type supports expressions that are found in the policy scope such as <code>action in [Action::"view", Action::"edit"]</code>.
This expression typechecks because the least upper bound of <code>Action::"view"</code> and <code>Action::"edit"</code> is <em>AnyEntity</em> so the expression is type <code>Set&lt;</code><em>AnyEntity</em><code>&gt;</code>.
Since <em>AnyEntity</em> cannot be used in strict validation, the current code special-cases the above expression, treating it as equivalent to <code>action in Action::"view" || action in Action::"edit"</code>.
However, this approach is unsatisfying as it only supports literal sets of <code>Action</code> entities.</p>
<p>It turns out we can resolve this issue by making all <code>Action</code> entities have one type -- <code>Action</code> -- in both strict and permissive validation.
This change strictly <em>adds</em> precision to validation, compared to the status quo.
Expressions like <code>[Action::"view", Action::"edit"]</code> have type <code>Set&lt;Action&gt;</code> and thus do not need <em>AnyEntity</em> to be well-typed.
Expressions like <code>if principal.isAdmin then Action::"edit" else Action::"editLimited"</code> will typecheck in strict validation, since both branches have the same type (<code>Action</code>).</p>
<p>A possible drawback of this change is that it will not allow distinct actions to have distinct attribute sets (if indeed we add attributes to actions in the future).
Rather, all actions must be typeable with the same record type.
As a mitigation, for action entities that have an attribute that others do not, the attribute can be made optional.
However, two entities would not be able to have the same attribute at <em>different</em> types, e.g., <code>{ foo: String }</code> vs. <code>{ foo: Long }</code>.
Arguably, this restriction is clearer and more intuitive than what would have been allowed before.</p>
<h3 id="template-slots"><a class="header" href="#template-slots">Template slots</a></h3>
<p>There are no restrictions on what entity type can be used to instantiate a slot in a template, so the permissive typechecker also uses <em>AnyEntity</em> here.
The only restriction on the type of a slot is that it must be instantiated with an entity type that exists in the schema.
The strict validator today does not properly support validating templates, which is something we want to allow.</p>
<p>Because <em>AnyEntity</em> cannot be used in strict validation, we will modify both permissive and strict validation to precisely typecheck a template by extending the query type environment to include a type environment for template slots.
Doing so will strictly <em>improve</em> precision for permissive validation; all templates that validated before will still do so after this change.</p>
<p>Here is how the change will work.
In the same way that we typecheck a policy once for each possible binding for the types of <code>principal</code> and <code>resource</code> for a given action, we will also typecheck a template once for every possible binding for the type of any slots in that template.</p>
<p>Typechecking for every entity type may seem excessive,
but we know that a template slot can only occur in an <code>==</code> or <code>in</code> expression in the policy scope where the <code>principal</code> or <code>resource</code> is compared to the slot.
We will infer the type <code>False</code> for these expression if the slot is an entity type that cannot be <code>==</code> or <code>in</code> the principal or resource entity type, short-circuiting the rest of typechecking for that type environment.
Typechecking could be optimized by recognizing and ignoring type environments that will be <code>False</code> based only on the policy scope.</p>
<p>For example, using the schema from the motivating example, the following template will typecheck.</p>
<pre><code>permit(principal == ?principal, action == Action::"read", resource);
</code></pre>
<p>Using the usual request type environment construction, there is one environment <code>(User, Action::"read", Object)</code>.
Because this is a template containing <code>?principal</code>, we extend the environment with each possible type for the slot: <code>User</code>, <code>Org</code>, <code>Admin</code> and <code>Object</code>.
When typechecking, the validator sees <code>principal == ?principal &amp;&amp; ...</code> first in every environment which is always an equality between two entity types.
The <code>principal</code> is always a <code>User</code> while <code>?principal</code> is one of the possible slot types depending on the type environment.
In every environment where <code>?principal</code> is not <code>User</code>, the equality has type <code>False</code>, causing the <code>&amp;&amp;</code> to short-circuit to type <code>False</code>.
The rest of the policy is typechecked as usual when <code>?principal</code> is <code>User</code>.</p>
<p>This change will match the precision of the validator today, and will enable more precise typechecking if we expand where in a policy template slots may be used.
In particular, if we allowed expressions like <code>?principal.foo == 2</code> in the condition of a policy, the above approach would allow us to know precisely that <code>?principal</code> will always have a <code>foo</code> attribute, whereas the current approach using <em>AnyEntity</em> would not be able to.</p>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h3>
<p>The current way we implement strict mode will change to accommodate these additions. We propose the following:</p>
<ol>
<li>Change the Rust code to implement strict mode by reusing the logic of permissive mode​ and using a flag to perform more restrictive checks. For example, when given <code>User</code> and <code>Admin</code> entity types, the code performing the least-upper-bound computation will return union type <code>User|Admin</code> in permissive mode, and will fail in strict mode. And, the code for conditionals would force branches' types to match in strict mode, but not in permissive mode. Etc.</li>
<li>When checking in strict mode, we construct a new AST that performs the needed transformations, as in step 2 today.</li>
<li>Either way, we can add type annotations. For strict mode, they could be added during the transformation; for permissive mode, no transformation is needed. No checking is done after annotations are added, since the checking is always done, regardless of mode, prior to the transformation.</li>
</ol>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>The main drawback of this approach is that strict-mode validation will be more restrictive. This is by design: Policies like the one in the motivating example will be rejected where before they were accepted. Accepting this RFC means we are prioritizing understandability over precision under the assumption that the lost precision will not be missed.</p>
<p>Policies that validated before but will not validate now are quite odd -- they would rely on the use of width subtyping, unions, etc. to determine that an expression will always evaluate to <code>true</code> (or <code>false</code>) and thus can be transformed away. But policies like these will be like those in the motivating example at the start of this RFC, and are probably not what the user intended in the first place. Ultimately, flagging them as erroneous is safer.</p>
<p>A secondary drawback is that this change will result in a non-trivial, and backwards-incompatible code change.
Mitigating this issue is that the backward incompatibility will be minimal in practice (per the above), and we will use verification-guided development to prove that the change is sound (i.e., will not introduce design or implementation mistakes).</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>The proposal is, we believe, the minimal change to make strict mode self-contained, but not too different from what was there before. It also should not result in pervasive changes to the existing code. Alternative designs we considered (e.g., allowing more permissive mode features in strict mode) would be more invasive.</p>
<h2 id="updates"><a class="header" href="#updates">Updates</a></h2>
<ul>
<li>2023-11-07: The original text said that the handling of unspecified entities needed to be adjusted. However, although released implementations of Cedar type unspecified entities as <code>AnyEntity</code>, <code>==</code> and <code>in</code> expressions involving unspecified entities are typed as <code>False</code> (rather than <code>Bool</code>). This provides the same behavior as using a special <code>Unspecified</code> type, as originally proposed in this RFC.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0009-disallow-whitespace-in-entityuid.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="0020-unique-record-keys.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0009-disallow-whitespace-in-entityuid.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="0020-unique-record-keys.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
