<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0055-remove-unspecified - Cedar RFC Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cedar RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="explicit-unspecified-entities"><a class="header" href="#explicit-unspecified-entities">Explicit Unspecified Entities</a></h1>
<h2 id="related-issues-and-prs"><a class="header" href="#related-issues-and-prs">Related issues and PRs</a></h2>
<ul>
<li>Related RFCs: <a href="https://github.com/cedar-policy/rfcs/pull/35">RFC35</a>, <a href="https://github.com/cedar-policy/rfcs/pull/47">RFC47</a></li>
<li>Implementation PR(s):</li>
</ul>
<h2 id="timeline"><a class="header" href="#timeline">Timeline</a></h2>
<ul>
<li>Started: 2024-02-27</li>
<li>Accepted: 2024-05-28</li>
<li>Landed: 2024-06-19 on <code>main</code> (<a href="https://github.com/cedar-policy/cedar/pull/983">#983</a>)</li>
<li>Released: TBD</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Cedar currently supports <em>unspecified entities</em>, which are entities of a special, unique type that have no attributes, and are not ancestors or descendants of any other entity in the store. Unspecified entities are intended to act as placeholders for entities that don’t influence authorization (see examples below).</p>
<p>The current implementation of unspecified entities results in several corner cases in our code (especially the validator), which have been difficult to maintain (see discussion on <a href="https://github.com/cedar-policy/cedar/pull/603">this recent PR</a>). The concept of unspecified entities is (in our opinion) confusing for users, and will only become more confusing once we stabilize the partial evaluation experimental feature, which allows “unknown” entities that are subtly different from “unspecified” entities.</p>
<p>This RFC proposes to drop Cedar support for unspecified entities, instead recommending that users create their own application-specific entity types that act like unspecified entities.</p>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic example</a></h2>
<p>Consider a "createFile" action that can be used by any <code>User</code>, as encoded in the following policy:</p>
<pre><code>permit(principal is User, action == Action::"createFile", resource);
</code></pre>
<p>When making an authorization request for this action, the principal should be a <code>User</code>, and the context can store information about the file to create, but it is unclear what the resource should be.
In fact, given the policy above, the resource <em>doesn't matter</em>.
In this case, a Cedar user may want to make the authorization request with a “dummy” resource; as of Cedar version 3.x, this is what <strong>unspecified entities</strong> are for.</p>
<p>Now consider a "createAccount" action. It's unclear what principal <em>or</em> resource should be used with this action. The approach above can be extended to this case too: make the action apply to an unspecified principal and resource. But now "unspecified" entities are being used to represent multiple distinct concepts: a file store, (unidentified) users creating an account, and a system that manages accounts.</p>
<p>This RFC proposes that users should instead explicitly create these "dummy" entities in an application-specific manner. For this example, the user should create entities of three types: <code>FileSystem</code>, <code>UnauthenticatedUser</code>, and <code>AccountManager</code>. The first will act as the principal for a "createFile" request, and the second and third will act as the principal and resource for a "createAccount" request.</p>
<p>This is (arguably) the approach we used in the <a href="https://github.com/cedar-policy/cedar-examples/tree/release/3.0.x/tinytodo">TinyTodo application</a>: we made a special <code>Application::“TinyTodo”</code> entity to act as the resource for the “CreateList” and “GetLists” actions.
This alternative is also in line with <a href="https://cedar-policy.slack.com/archives/C0547KH7R19/p1706656288284189">our previous suggestion</a> to use an application-specific <code>Unauthenticated</code> type to represent "unauthenticated" users, rather than using unspecified entities.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Unspecified entities are a confusing concept, as evidenced by messy special casing in our own code and multiple RFCs to refine their behavior (<a href="https://github.com/cedar-policy/rfcs/pull/35">RFC35</a>, <a href="https://github.com/cedar-policy/rfcs/pull/47">RFC47</a>).
We expect that this concept will only become more confusing once we stabilize the partial evaluation experimental feature, which allows “unknown” entities that are subtly different from "unspecified" entities, despite sharing similar names.</p>
<p>Unspecified entities also lead to two sharp corners in our public API:</p>
<ol>
<li>Omitting a <code>appliesTo</code> field in the schema (or setting it to null) means that an action applies only to unspecified entities, while using an empty list means that it applies to no entities. There is no way to say that an action applies to both unspecified entities and other types of entities. For more discussion, see <a href="https://github.com/cedar-policy/rfcs/pull/35">RFC35</a>. (Note: RFC35 has been closed in favor of the current RFC.)</li>
<li>It is unclear how we should create <code>Request</code>s that use both unspecified and unknown entities. This has not been an issue so far since partial evaluation and its APIs are experimental, but we are looking to stabilize them soon. Currently the best (although not ideal) proposal is to use a builder pattern for <code>Request</code>s (e.g., <code>request.principal(Some(User::"alice"))</code> sets the principal field of a request). To set a field to be “unspecified” users could pass in <code>None</code> instead of <code>Some(_)</code>; to set a field to be unknown users would not call the field constructor at all.</li>
</ol>
<h3 id="aside-unspecified-vs-unknown"><a class="header" href="#aside-unspecified-vs-unknown">Aside: Unspecified vs. unknown</a></h3>
<p>Unspecified and unknown entities are both pre-defined "dummy" entities that act like any other entity, as long as they are unused or only used in a trivial way (e.g., <code>principal == principal</code>).
If a policy uses an <em>unknown entity</em> in a non-trivial way, then evaluation will produce a residual.
If a policy uses an <em>unspecified entity</em> in a non-trivial way, then evaluation will produce an error.</p>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<h3 id="status-quo"><a class="header" href="#status-quo">Status quo</a></h3>
<p>As of Cedar v3.x, the only way to construct an unspecified entity is by passing <code>None</code> as a component when building a <a href="https://docs.rs/cedar-policy/latest/cedar_policy/struct.Request.html"><code>Request</code></a>.
So a request for the "createFile" action above might look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    principal: Some(User::"alice"),
    action: Some(Action::"createFile"),
    resource: None,
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>In the schema, the only way to say that an action applies to an unspecified entity is by omitting the relevant <code>appliesTo</code> field.
For example, the following schemas specify that the "createFile" action applies (only) to an unspecified resource.</p>
<p>Cedar schema syntax (<a href="https://github.com/cedar-policy/rfcs/blob/main/text/0024-schema-syntax.md">RFC 24</a>):</p>
<pre><code>action createFile
  appliesTo { principal: [User] };
</code></pre>
<p>Cedar schema JSON syntax:</p>
<pre><code class="language-json">"createFile": {
    "appliesTo": {
        "principal": ["User"]
    }
}
</code></pre>
<h3 id="proposal"><a class="header" href="#proposal">Proposal</a></h3>
<p>The proposal is simple: stop allowing the syntax above. The <code>Request</code> constructor will no longer accept optional arguments and schemas will no longer support missing <code>appliesTo</code> fields. The <code>Request</code> constructor API will be changed to require an <code>EntityUid</code> (instead of <code>Option&lt;EntityUid&gt;</code>) for the principal/action/resource, requiring code changes in programs using Cedar's Rust APIs. The schema APIs will not change, but omitting an <code>appliesTo</code> field will result in a parse error.</p>
<h3 id="relation-to-rfc35"><a class="header" href="#relation-to-rfc35">Relation to RFC35</a></h3>
<p>This RFC combines nicely with the (accepted) <a href="https://github.com/cedar-policy/rfcs/pull/53">RFC53 (Enumerated Entity Types)</a>, which allows users to fix the instances for a particular entity type. This means that custom "unspecified" entities can be easily restricted to a small set of possible entities. For example, RFC53 allows specifying that only <code>Application::"TinyTodo"</code> is valid, and no other <code>Application::"eid"</code>.</p>
<h3 id="upgrade-strategy"><a class="header" href="#upgrade-strategy">Upgrade strategy</a></h3>
<p>We appreciate that this RFC proposes a breaking change for Cedar's users, and the upgrade path is non-trivial  because it requires users to look carefully at their applications, and decide what they should use <em>instead</em> of unspecified entities.
To help, while implementing this RFC, we plan to develop a <strong>blog post</strong> with examples of applications where you may have used an "unspecified" entity, and what we think you should use instead (suggestions for examples are welcome!).</p>
<p>We also plan to provide APIs (hidden behind a flag, like our experimental features) for the following operations, with the same API and behavior that was available in 3.x.</p>
<ul>
<li>Parsing a schema in the Cedar schema format</li>
<li>Parsing a schema in the Cedar JSON schema format</li>
<li>Constructing a request</li>
</ul>
<p>This will allow services that build on top of Cedar (e.g., <a href="https://aws.amazon.com/verified-permissions/">Amazon Verified Permissions</a>) to handle this upgrade for their customers invisibly.
The implementation will follow the approach outlined in <a href="#alternative-b---maintain-the-status-quo-but-clean-up-the-implementation">Alternative B</a>.
However, <em>we will not maintain these APIs indefinitely</em> so you will need to support the new changes eventually. Please reach out to us if there's a way that we can help.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="alternative-a---predefine-a-special-unspecified-entity-type"><a class="header" href="#alternative-a---predefine-a-special-unspecified-entity-type">Alternative A - Predefine a special "unspecified" entity type</a></h3>
<p>Continue to support unspecified entities, but re-brand them as "default" entities, with the intuition that you should use them when you want <em>some default value</em> to pass into an authorization request.
This alternative proposes to give an explicit name to the unspecified entity type (<code>__cedar::Default</code>) and to require this name to be used in requests and schemas that use this type.</p>
<p>Under this proposal, the schema definition for the "createFile" action from above would look like:</p>
<pre><code>action createFile
  appliesTo { principal: [User], resource: [__cedar::Default] };
</code></pre>
<p>and a (pseudo-syntax) request for this action might be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    principal: EntityUid(User::"alice"),
    action: EntityUid(Action::"createFile"),
    resource: Default,
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>where the type of the <code>Request</code> constructor is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RequestEntity {
    Default,
    Unknown,
    EntityUid(EntityUid)
}

pub fn new(
        principal: RequestEntity,
        action: RequestEntity,
        resource: RequestEntity,
        context: Context,
        schema: Option&lt;&amp;Schema&gt;,
    ) -&gt; Result&lt;Self, RequestValidationError&gt;
...
<span class="boring">}</span></code></pre></pre>
<p>(<em>Note</em>: the <code>Unknown</code> variant may be hidden behind the "partial-eval" experimental flag, depending on when this RFC is implemented.)</p>
<p>Users will not be allowed to include entities of type <code>__cedar::Default</code> in the store, which ensures that these entities will never have attributes or ancestors/descendants, which are properties we will rely on during validation.
Users will not be allowed to reference the type <code>__cedar::Default</code> in their policies (so neither <code>principal == __cedar::Default::"principal"</code> nor <code>principal is __cedar::Default</code> are allowed).
Users do not need to add <code>__cedar::Default</code> to their schemas (and it will be an error if they do) because <code>__cedar::Default</code> is defined automatically.
Finally, users cannot create entity uids with type <code>__cedar::Default</code>, which prevents using default entities with the <code>RequestEntity::EntityUid</code> constructor.</p>
<h4 id="naming-specifics"><a class="header" href="#naming-specifics">Naming specifics</a></h4>
<p>The names <code>RequestEntity</code> and <code>__cedar::Default</code> are both subject to change.</p>
<p>For the latter, we have agreed that we want to use the <code>__cedar</code> prefix (reserved as part of <a href="https://github.com/cedar-policy/cedar/pull/557">cedar#557</a> in v3.1), but the exact type name is up for debate.
Options we've considered include:</p>
<ul>
<li><code>None</code></li>
<li><code>Null</code></li>
<li><code>Ghost</code></li>
<li><code>Dummy</code></li>
<li><code>Empty</code></li>
<li><code>Irrelevant</code></li>
<li><code>Generic</code></li>
</ul>
<p>Here are some options we’ve ruled out:</p>
<ul>
<li><code>Any</code>: possibility to confuse the scope condition <code>principal</code> with <code>principal is __cedar::Any</code>. The first applies to any principal, while the latter applies to only the default entity.</li>
<li><code>Arbitrary</code>: same issue as "any"</li>
<li><code>Unspecified</code>: potential for confusion with partial evaluation "unknown"</li>
<li><code>Mock</code>: implies that this entity type should be used for debugging/testing</li>
</ul>
<h4 id="discussion-notes"><a class="header" href="#discussion-notes">Discussion notes</a></h4>
<p>We considered this alternative seriously, and it even became the main proposal for a period of time.
But ultimately we decided that this alternative feels like a temporary solution, and we would eventually want to get rid of unspecified/default entities anyways.</p>
<p>Here's a nice (lightly edited) summary from @max2me:</p>
<blockquote>
<p>Both the main proposal and Alternative A are breaking changes, so I'd rather go a step forward and require customers to update schema, code, and policies once for the benefit of a brighter future (Alternative A would require customers to update just schema and code, yet all the same testing will have to occur).</p>
<p>My concerns with Alternative A:</p>
<ul>
<li>Lack of symmetry -- you omit something in the policy and yet explicitly mention it in the authorization code and schema. This leads to a fragmented experience of working with Cedar as a technology.</li>
<li>Surprise factor -- I suspect that most customers who leave principal/resource unscoped in policies will not realize that in addition to all the entities they reference in their code, there is a hidden default type.</li>
</ul>
<p>In my opinion, occasional duplication of policies and the need to define your own default type is a small cost to pay for the overall simplicity and cohesiveness of the system.</p>
</blockquote>
<h3 id="alternative-b---maintain-the-status-quo-but-clean-up-the-implementation"><a class="header" href="#alternative-b---maintain-the-status-quo-but-clean-up-the-implementation">Alternative B - Maintain the status quo, but clean up the implementation</a></h3>
<p>Pre-define the <code>__cedar::Default</code> entity type as in Alternative A, but do not allow users to reference it directly.
Instead, update the underlying implementation to use the new type while leaving the current API as-is.
We took this approach in the <a href="https://github.com/cedar-policy/cedar-spec/tree/main/cedar-lean">Lean model</a> to avoid special handling for unspecified entities, and it seems to have worked out well.
Differential testing has given us confidence that it leads to the same behavior as our current implementation.</p>
<p><em>Note</em>: This alternative should result in no changes from the user’s perspective. If it does result in changes (e.g., to validation results) then this was unintentional behavior of our current implementation, and should be treated as a bug fix.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0053-enum-entities.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="0057-general-multiplication.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0053-enum-entities.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="0057-general-multiplication.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
